# #在ES6中声明命令有6种：

##（1）var

 + 声明变量；
 + 会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined；
 + 可重复声明，后面声明的会覆盖前面声明的；

##（2）function

​	声明函数；

##（3）let

+ 声明变量，类似于var；

+ 只在let命令的代码块有效;

+ 不存在变量提升，它所声明的变量一定要在声明后使用，否则报错 ；

+ 暂时性死区（temporal dead zone，简称 TDZ） ，即只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响；

  ```js
  var a = 10;
  if(true){
      // TDZ开始
      // console.log(a);//Uncaught ReferenceError: a is not defined
      let a;//TDZ结束
      console.log(a);//undefined
      a = 10;
      console.log(a);//10
  }
  ```

+ 不允许在相同作用域内，重复声明同一个变量；

##（4）const

+ 声明一个只读的常量。一旦声明，常量的值就不能改变;

+ 只在声明所在的块级作用域内有效;

+ const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用;

+ const声明的常量，也与let一样不可重复声明;

  

	 ​	const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 

##（5）class

##（6）import

> var和function是ES5中的，后面四种都是ES6中的。

# #顶层对象

在浏览器环境指的是window对象，在 Node 指的是global对象。 

- 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
- 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
- Node 里面，顶层对象是global，但其他环境都不支持。